use std::{fs::File, io::Read};

use serde::Serialize;

use crate::utils::error::{Error, Result};

use super::Repository;

#[derive(Clone, Serialize)]
pub struct App {
  categories: Vec<String>,
  suggested_version_code: String,
  license: String,
  name: String,
  added: i64,
  package_name: String,
  last_updated: i64,
  packages: Vec<Package>,
}

impl App {
  /// Reads a Json Value and tries to extract all fields to create a list of apps
  ///
  /// returns None if any field can't be converted
  fn from_json(value: &serde_json::Value) -> Option<Vec<Self>> {
    // get both lists
    let apps = value.get("apps")?;
    let packages = value.get("packages")?;

    let mut apps_vec = vec![];

    // map all app fields
    for app in apps.as_array()? {
      let name = app.get("name")?.as_str()?.to_owned();
      let suggested_version_code = app.get("suggestedVersionCode")?.as_str()?.to_owned();
      let license = app.get("license")?.as_str()?.to_owned();
      let package_name = app.get("packageName")?.as_str()?.to_owned();
      let last_updated = app.get("lastUpdated")?.as_i64()?.to_owned();
      let added = app.get("added")?.as_i64()?.to_owned();

      let mut categories = vec![];

      // get all categories (are saved in a map)
      for category in app.get("categories")?.as_array()? {
        categories.push(category.as_str()?.to_string());
      }

      let mut packages_vec = vec![];

      let package = packages.get(&package_name)?;

      // map all package fields
      for package_entry in package.as_array()? {
        packages_vec.push(Package::from_json(package_entry)?);
      }

      apps_vec.push(App {
        name,
        suggested_version_code,
        license,
        package_name,
        last_updated,
        added,
        packages: packages_vec,
        categories,
      });
    }

    Some(apps_vec)
  }
}

#[derive(Clone, Serialize)]
pub struct Package {
  added: i64,
  apk_name: String,
  hash: String,
  hash_type: String,
  max_sdk_version: Option<u32>,
  min_sdk_version: Option<u32>,
  nativecode: Vec<String>,
  package_name: String,
  sig: String,
  signer: String,
  size: u64,
  target_sdk_version: Option<u32>,
  uses_permission: Vec<(String, Option<u32>)>,
  version_code: u64,
  version_name: String,
}

impl Package {
  /// Reads a Json Value and tries to extract all fields to create an instance of Package
  ///
  /// returns None if any field can't be converted
  fn from_json(value: &serde_json::Value) -> Option<Self> {
    let added = value.get("added")?.as_i64()?;
    let apk_name = value.get("apkName")?.as_str()?.to_owned();
    let hash = value.get("hash")?.as_str()?.to_owned();
    let hash_type = value.get("hashType")?.as_str()?.to_owned();
    let max_sdk_version = value
      .get("maxSdkVersion")
      .map(|val| val.as_u64())
      .flatten()
      .map(|val| val.try_into().ok())
      .flatten();
    let min_sdk_version = value
      .get("minSdkVersion")
      .map(|val| val.as_u64())
      .flatten()
      .map(|val| val.try_into().ok())
      .flatten();

    let mut nativecode = vec![];

    for nativecode_entry in value.get("nativecode")?.as_array()? {
      nativecode.push(nativecode_entry.as_str()?.to_owned());
    }

    let package_name = value.get("packageName")?.as_str()?.to_owned();
    let sig = value.get("sig")?.as_str()?.to_owned();
    let signer = value.get("signer")?.as_str()?.to_owned();
    let size = value.get("size")?.as_u64()?;
    let target_sdk_version = value
      .get("targetSdkVersion")
      .map(|val| val.as_u64())
      .flatten()
      .map(|val| val.try_into().ok())
      .flatten();

    let mut uses_permission = vec![];

    for uses_permission_entry in value
      .get("uses-permission")
      .unwrap_or(&serde_json::Value::Null)
      .as_array()
      .unwrap_or(&vec![])
    {
      uses_permission.push((
        uses_permission_entry.get(0)?.as_str()?.to_owned(),
        uses_permission_entry
          .get(1)?
          .as_i64()
          .and_then(|val| val.try_into().ok()),
      ));
    }

    let version_code = value.get("versionCode")?.as_u64()?;
    let version_name = value.get("versionName")?.as_str()?.to_owned();

    Some(Self {
      added,
      apk_name,
      hash,
      hash_type,
      max_sdk_version,
      min_sdk_version,
      nativecode,
      package_name,
      sig,
      signer,
      size,
      target_sdk_version,
      uses_permission,
      version_code,
      version_name,
    })
  }
}

impl Repository {
  /// Reads the index file generated by fdroid and returns all apps
  ///
  /// Returns an error if the json file can't be mapped correctely
  pub fn get_apps(&self) -> Result<Vec<App>> {
    let index_file = self.path.join("repo/index-v1.json");

    if !index_file.exists() {
      // if no index file exists, no apps exist
      return Ok(vec![]);
    }

    let mut file = File::open(index_file)?;
    let mut file_content = String::new();
    file.read_to_string(&mut file_content)?;

    App::from_json(
      &serde_json::from_str(&file_content)
        .map_err(|_| Error::JsonConvertError("Could not read repository index file!".to_owned()))?,
    )
    .ok_or(Error::JsonConvertError(
      "Could not map repository index file!".to_owned(),
    ))
  }
}
