use std::{
  fs::{self, File},
  io::{self, Read},
  path::PathBuf,
};

use actix_multipart::form::tempfile::TempFile;
use log::warn;
use serde::Serialize;

use crate::utils::error::{Error, Result};

use super::Repository;

#[derive(Clone, Serialize)]
pub struct App {
  categories: Vec<String>,
  suggested_version_code: String,
  license: String,
  name: String,
  added: i64,
  package_name: String,
  last_updated: i64,
  packages: Vec<Package>,
}

impl App {
  /// Reads a Json Value and tries to extract all fields to create a list of apps
  ///
  /// returns None if any field can't be converted
  fn from_json(value: &serde_json::Value) -> Option<Vec<Self>> {
    // get both lists
    let apps = value.get("apps")?;
    let packages = value.get("packages")?;

    let mut apps_vec = vec![];

    // map all app fields
    for app in apps.as_array()? {
      let name = app.get("name")?.as_str()?.to_owned();
      let suggested_version_code = app.get("suggestedVersionCode")?.as_str()?.to_owned();
      let license = app.get("license")?.as_str()?.to_owned();
      let package_name = app.get("packageName")?.as_str()?.to_owned();
      let last_updated = app.get("lastUpdated")?.as_i64()?.to_owned();
      let added = app.get("added")?.as_i64()?.to_owned();

      let mut categories = vec![];

      // get all categories (are saved in a map)
      for category in app.get("categories")?.as_array()? {
        categories.push(category.as_str()?.to_string());
      }

      let mut packages_vec = vec![];

      let package = packages.get(&package_name)?;

      // map all package fields
      for package_entry in package.as_array()? {
        packages_vec.push(Package::from_json(package_entry)?);
      }

      apps_vec.push(App {
        name,
        suggested_version_code,
        license,
        package_name,
        last_updated,
        added,
        packages: packages_vec,
        categories,
      });
    }

    Some(apps_vec)
  }
}

#[derive(Clone, Serialize)]
pub struct Package {
  added: i64,
  apk_name: String,
  hash: String,
  hash_type: String,
  max_sdk_version: Option<u32>,
  min_sdk_version: Option<u32>,
  nativecode: Vec<String>,
  package_name: String,
  sig: String,
  signer: String,
  size: u64,
  target_sdk_version: Option<u32>,
  uses_permission: Vec<(String, Option<u32>)>,
  version_code: u64,
  version_name: String,
}

impl Package {
  /// Reads a Json Value and tries to extract all fields to create an instance of Package
  ///
  /// returns None if any field can't be converted
  fn from_json(value: &serde_json::Value) -> Option<Self> {
    let added = value.get("added")?.as_i64()?;
    let apk_name = value.get("apkName")?.as_str()?.to_owned();
    let hash = value.get("hash")?.as_str()?.to_owned();
    let hash_type = value.get("hashType")?.as_str()?.to_owned();
    let max_sdk_version = value
      .get("maxSdkVersion")
      .map(|val| val.as_u64())
      .flatten()
      .map(|val| val.try_into().ok())
      .flatten();
    let min_sdk_version = value
      .get("minSdkVersion")
      .map(|val| val.as_u64())
      .flatten()
      .map(|val| val.try_into().ok())
      .flatten();

    let mut nativecode = vec![];

    for nativecode_entry in value.get("nativecode")?.as_array()? {
      nativecode.push(nativecode_entry.as_str()?.to_owned());
    }

    let package_name = value.get("packageName")?.as_str()?.to_owned();
    let sig = value.get("sig")?.as_str()?.to_owned();
    let signer = value.get("signer")?.as_str()?.to_owned();
    let size = value.get("size")?.as_u64()?;
    let target_sdk_version = value
      .get("targetSdkVersion")
      .map(|val| val.as_u64())
      .flatten()
      .map(|val| val.try_into().ok())
      .flatten();

    let mut uses_permission = vec![];

    for uses_permission_entry in value
      .get("uses-permission")
      .unwrap_or(&serde_json::Value::Null)
      .as_array()
      .unwrap_or(&vec![])
    {
      uses_permission.push((
        uses_permission_entry.get(0)?.as_str()?.to_owned(),
        uses_permission_entry
          .get(1)?
          .as_i64()
          .and_then(|val| val.try_into().ok()),
      ));
    }

    let version_code = value.get("versionCode")?.as_u64()?;
    let version_name = value.get("versionName")?.as_str()?.to_owned();

    Some(Self {
      added,
      apk_name,
      hash,
      hash_type,
      max_sdk_version,
      min_sdk_version,
      nativecode,
      package_name,
      sig,
      signer,
      size,
      target_sdk_version,
      uses_permission,
      version_code,
      version_name,
    })
  }
}

impl Repository {
  /// Reads the index file generated by fdroid and returns all apps
  ///
  /// Returns an error if the json file can't be mapped correctely
  pub fn get_apps(&self) -> Result<Vec<App>> {
    let index_file = self.repo_path().join("index-v1.json");

    if !index_file.exists() {
      // if no index file exists, no apps exist
      return Ok(vec![]);
    }

    let mut file = File::open(index_file)?;
    let mut file_content = String::new();
    file.read_to_string(&mut file_content)?;

    App::from_json(
      &serde_json::from_str(&file_content)
        .map_err(|_| Error::JsonConvertError("Could not read repository index file!".to_owned()))?,
    )
    .ok_or(Error::JsonConvertError(
      "Could not map repository index file!".to_owned(),
    ))
  }

  /// Uploads a file directly to the app repository
  pub fn upload_app(&self, file: TempFile) -> Result<()> {
    // save file
    let new_file_path = self.repo_path().join(
      file
        .file_name
        .as_ref()
        .clone()
        .ok_or(Error::UserError("File has no name!".to_owned()))?,
    );

    // if file already exists, warn
    if new_file_path.clone().exists() {
      warn!(
        "File already exists, overriding existing file: {:?}",
        new_file_path
      );
    }

    self.persist_temp_file(file, new_file_path.clone())?;

    // update meta data
    let update_result = self.update();

    // cleanup if error
    if update_result.is_err() {
      if new_file_path.exists() && new_file_path.is_file() {
        fs::remove_file(new_file_path).map_err(Error::from)?;
      }
    }

    Ok(())
  }

  /// Saves a temporary file to a final location
  ///
  /// Needed because file.persist() throws error if the destination directory is mounted inside a docker container
  fn persist_temp_file(&self, file: TempFile, path: PathBuf) -> Result<File> {
    // create temporary directory
    let temp_dir_path = PathBuf::from("/tmp/files");
    if !temp_dir_path.exists() {
      fs::create_dir_all(temp_dir_path.clone()).map_err(Error::from)?;
    }

    // save file to temporary directory
    let persistent_temp_file_path = temp_dir_path.join(
      path
        .file_name()
        .ok_or(Error::CustomError("File Name not provided!".to_owned()))?,
    );

    // persist file to temporary location
    file
      .file
      .persist(persistent_temp_file_path.clone())
      .map_err(io::Error::from)
      .map_err(Error::from)?;

    // copy file
    let file_copy_result = fs::copy(persistent_temp_file_path.clone(), path.clone())
      .map_err(Error::from)
      .map(|_| ());

    // remove old file
    fs::remove_file(persistent_temp_file_path).map_err(Error::from)?;

    // if copy operation was unsucessful, return here
    file_copy_result?;

    File::open(path).map_err(Error::from)
  }
}
